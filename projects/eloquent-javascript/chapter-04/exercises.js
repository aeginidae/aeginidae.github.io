////////////////////////////////////////////////////////////////////////////////
// range ///////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

function range(start, end, step = 1) {
    // returns an array containing each number from
    // start to end, inclusive. 'step' specifies the
    // distance between each array entry, e.g. range(1, 3, 2)
    // would yield [1,3]. Negative step values are acceptable.
    const result = [];
    if (start === end) {
        return [];
    } else if (step > 0) {
        for (let i = start; i <= end; i += step) {
            result.push(i);
        }
    } else {
        for (let i = start; i >= end; i += step) {
            result.push(i);
        }
    }
    return result;
}

////////////////////////////////////////////////////////////////////////////////
// sum /////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

const sum = arr => arr.length === 0 ? 0 : arr.reduce((x, y) => x + y);

////////////////////////////////////////////////////////////////////////////////
// reverseArray ////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

function reverseArray(arr) {
  const result = [];
  for (let i = arr.length - 1; i >= 0; i--) {
      result.push(arr[i]);
  }
  return result;
}

////////////////////////////////////////////////////////////////////////////////
// reverseArrayInPlace /////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

function reverseArrayInPlace(arr) {
    for (let i = 0; i < Math.floor(arr.length / 2); i++) {     
            // Math.floor(arr.length / 2) because we only need
            // to iterate over half of the array rounded down
        [arr[i], arr[arr.length - i - 1]] = [arr[arr.length - i - 1], arr[i]];
            // this is ES6 destructuring assignment for swapping
            // variable values in place, i.e. [a, b] = [b, a].
            // we're starting from the outermost pair of values
            // in the array, stepping inward as i increments.
    }
}

////////////////////////////////////////////////////////////////////////////////
// arrayToList /////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

function arrayToList(arr) {
    if (arr.length === 1) {
        return {value: arr[0], rest: null};
    }
    else {
        return {value: arr[0], rest: arrayToList(arr.slice(1))};
    }
}

////////////////////////////////////////////////////////////////////////////////
// listToArray /////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

function listToArray(list) {
    if (list.rest === null) {
        return [list.value];
    }
    else {
        return [list.value].concat(listToArray(list.rest));
    }
}

////////////////////////////////////////////////////////////////////////////////
// prepend /////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

function prepend(element, list) {
    return {value: element, rest: list};
}

////////////////////////////////////////////////////////////////////////////////
// nth /////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

function nth(list, number) {
    const arr = listToArray(list);
    return number < arr.length ? arr[number] : undefined;
}

////////////////////////////////////////////////////////////////////////////////
// deepEqual ///////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

function deepEqual(x, y) {
    if (typeof x == typeof y) {
        if (typeof x == "object" && !(x == null || y == null)) {
            return objectCompare(x, y);
        }
        else if (x == y) {
            return true;
        }
        else {
            return false;
        }
    } else {
        return false;
    }
}

function objectCompare(x, y) {
    const [xKeys, yKeys] = [Object.keys(x), Object.keys(y)];
        if (xKeys.join('') == yKeys.join('')) {
            for (let i = 0; i < xKeys.length; i++) {
                if (!deepEqual(x[xKeys[i]], y[yKeys[i]])) {
                    return false;
                }
            }
        return true;
    }
}

////////////////////////////////////////////////////////////////////////////////
// DON'T REMOVE THIS CODE //////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

if ((typeof process !== 'undefined') &&
  (typeof process.versions.node !== 'undefined')) {
  module.exports = {
    range,
    sum,
    reverseArray,
    reverseArrayInPlace,
    arrayToList,
    listToArray,
    prepend,
    nth,
    deepEqual,
  };
};
